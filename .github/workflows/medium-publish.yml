import os
import requests
import json
import frontmatter
import markdown2
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import time
import glob
from datetime import datetime

# Email configuration
TO_EMAIL = os.environ['TO_EMAIL']
FROM_EMAIL = os.environ['FROM_EMAIL']
EMAIL_PASSWORD = os.environ['EMAIL_PASSWORD']
MEDIUM_TOKEN = os.environ['MEDIUM_TOKEN']

def send_email(subject, body, is_html=False):
    """Send email notification with the given subject and body."""
    msg = MIMEMultipart('alternative')
    msg['From'] = FROM_EMAIL
    msg['To'] = TO_EMAIL
    
    # Add current date to the subject
    current_date = datetime.now().strftime("%Y-%m-%d")
    msg['Subject'] = f"{subject} - {current_date}"

    # Attach the appropriate content type
    if is_html:
        msg.attach(MIMEText(body, 'html'))
    else:
        msg.attach(MIMEText(body, 'plain'))

    try:
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(FROM_EMAIL, EMAIL_PASSWORD)
        text = msg.as_string()
        server.sendmail(FROM_EMAIL, TO_EMAIL, text)
        server.quit()
        print(f"Email sent: {msg['Subject']}")
    except Exception as e:
        print(f"Failed to send email: {e}")

def get_medium_user_id():
    """Get Medium user ID using the API token."""
    headers = {
        'Authorization': f'Bearer {MEDIUM_TOKEN}',
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    
    user_response = requests.get('https://api.medium.com/v1/me', headers=headers)
    if user_response.status_code != 200:
        raise Exception(f"Error getting Medium user: {user_response.text}")
    
    return user_response.json()['data']['id']

def publish_article(article_path, user_id):
    """Publish an article to Medium."""
    with open(article_path, 'r', encoding='utf-8') as f:
        post = frontmatter.load(f)
    
    title = post.get('title', 'Untitled Article')
    tags = post.get('tags', [])
    content = post.content
    html_content = markdown2.markdown(content)
    
    headers = {
        'Authorization': f'Bearer {MEDIUM_TOKEN}',
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    
    payload = {
        'title': title,
        'contentFormat': 'html',
        'content': html_content,
        'tags': tags,
        'publishStatus': 'public'
    }
    
    post_url = f'https://api.medium.com/v1/users/{user_id}/posts'
    response = requests.post(post_url, headers=headers, data=json.dumps(payload))
    
    if response.status_code == 201:
        # Get the Medium post URL
        medium_url = response.json()['data']['url']
        return True, title, medium_url
    else:
        return False, title, response.text

def create_html_report(logs, published_count):
    """Create a well-formatted HTML report."""
    current_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    html = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <style>
            body {{
                font-family: Arial, sans-serif;
                line-height: 1.6;
                color: #333;
                max-width: 800px;
                margin: 0 auto;
                padding: 20px;
            }}
            h1 {{
                color: #2c3e50;
                border-bottom: 2px solid #3498db;
                padding-bottom: 10px;
            }}
            .summary {{
                background-color: #f8f9fa;
                padding: 15px;
                border-radius: 5px;
                margin-bottom: 20px;
            }}
            table {{
                width: 100%;
                border-collapse: collapse;
                margin-top: 20px;
            }}
            th, td {{
                padding: 12px 15px;
                border: 1px solid #ddd;
                text-align: left;
            }}
            th {{
                background-color: #3498db;
                color: white;
            }}
            tr:nth-child(even) {{
                background-color: #f2f2f2;
            }}
            .success {{
                color: #27ae60;
            }}
            .failure {{
                color: #e74c3c;
            }}
            .footer {{
                margin-top: 30px;
                font-size: 12px;
                color: #7f8c8d;
                text-align: center;
            }}
        </style>
    </head>
    <body>
        <h1>Medium Publishing Report</h1>
        
        <div class="summary">
            <p><strong>Date:</strong> {current_date}</p>
            <p><strong>Articles Published:</strong> {published_count}</p>
            <p><strong>Total Articles Processed:</strong> {len(logs)}</p>
        </div>
        
        <table>
            <tr>
                <th>Status</th>
                <th>Article Title</th>
                <th>Result</th>
            </tr>
    """
    
    for log in logs:
        if log.startswith("✅"):
            # Extract title and URL from success message
            parts = log.split("✅ Successfully published: '")[1].split("' - ")
            title = parts[0]
            url = parts[1]
            
            html += f"""
            <tr>
                <td><span class="success">✅ Success</span></td>
                <td>{title}</td>
                <td><a href="{url}" target="_blank">{url}</a></td>
            </tr>
            """
        elif log.startswith("❌"):
            # Extract title and error from failure message
            parts = log.split("❌ Failed to publish '")[1].split("'. Error: ")
            title = parts[0]
            error = parts[1]
            
            html += f"""
            <tr>
                <td><span class="failure">❌ Failed</span></td>
                <td>{title}</td>
                <td>{error}</td>
            </tr>
            """
    
    html += """
        </table>
        
        <div class="footer">
            <p>This is an automated email sent by GitHub Actions workflow.</p>
        </div>
    </body>
    </html>
    """
    
    return html

def main():
    # Find markdown files in the articles directory
    article_files = glob.glob('articles/*.md')
    
    # Check if articles directory exists
    if not os.path.exists('articles'):
        msg = "Articles directory not found!"
        print(msg)
        send_email("Medium Publishing - No Articles Directory", msg)
        return
    
    # Check if any articles are available
    if not article_files:
        msg = "No articles found for publishing in the articles directory."
        print(msg)
        send_email("Medium Publishing - No Articles Found", msg)
        return
    
    # Create publish directory if it doesn't exist
    os.makedirs('publish', exist_ok=True)
    
    # Get only the first 3 articles
    articles_to_publish = article_files[:3]
    
    # Log messages
    logs = []
    published_articles = []
    
    try:
        # Get Medium user ID
        user_id = get_medium_user_id()
        
        # Process each article
        for article_path in articles_to_publish:
            filename = os.path.basename(article_path)
            print(f"Processing {article_path}")
            
            success, title, result = publish_article(article_path, user_id)
            
            if success:
                logs.append(f"✅ Successfully published: '{title}' - {result}")
                published_articles.append(title)
                
                # Move the article to the published folder
                target_path = os.path.join("publish", filename)
                os.system(f'git mv "{article_path}" "{target_path}"')
            else:
                logs.append(f"❌ Failed to publish '{title}'. Error: {result}")
            
            # Sleep to avoid API rate limits
            time.sleep(3)
        
        # Commit and push changes if any articles were published
        if published_articles:
            os.system('git add .')
            commit_msg = "Published " + ", ".join([f"'{title}'" for title in published_articles]) + " to Medium"
            os.system(f'git commit -m "{commit_msg}"')
            os.system('git push')
            
        # Send email with logs - both plain text and HTML versions
        log_text = "\n".join(logs) if logs else "No articles were processed."
        html_report = create_html_report(logs, len(published_articles))
        send_email("Medium Publishing Log", html_report, is_html=True)
        
    except Exception as e:
        error_msg = f"Exception occurred: {str(e)}"
        print(error_msg)
        send_email("Medium Publishing Error", error_msg)

if __name__ == "__main__":
    main()